/********************************************************************************
**
**	Copyright (C) 2007-2017 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org or write info@imagingtools.de for further
** 	information about the ACF.
**
********************************************************************************/


#include <iocv/CCharucoPerspectiveCalibrationSupplierComp.h>


// ACF include
#include <ilog/CExtMessage.h>
#include <iprm/TParamsPtr.h>
#include <i2d/CPosition2d.h>

// ACF-Solutions includes
#include <iipr/CPerspCalibFinder.h>
#include <iipr/CPointGridFeature.h>
#include <iocv/COcvPointGridExtractorComp.h>
#include <iocv/CCharucoBoard.h>


namespace iocv
{


	struct PointGridConsumer : public iipr::IFeaturesConsumer
	{
		// reimplemented (iipr::IFeaturesConsumer)
		virtual void ResetFeatures() override {
			m_points.Reset();
			m_ids.clear();
		}

		virtual bool AddFeature(const imeas::INumericValue* featurePtr, bool* /*isFullPtr = NULL*/) override
		{
			if (featurePtr != NULL) {
				const icalib::CPointGrid* pointGridPtr = dynamic_cast<const icalib::CPointGrid*>(featurePtr);
				if (pointGridPtr != NULL) {
					m_points.CopyFrom(*pointGridPtr);

					const iipr::CPointGridFeature* gridFeaturePtr = dynamic_cast<const iipr::CPointGridFeature*>(featurePtr);
					if (gridFeaturePtr) {
						const std::vector<int>& ids = gridFeaturePtr->GetCharucoIds();
						if (ids.size() > 0){
							m_ids = ids;
						}
					}
				}

				delete featurePtr;
			}

			return true;
		}

		icalib::CPointGrid m_points;
		std::vector<int> m_ids;
	};


// methods of CCharucoPerspectiveCalibrationSupplier

// reimplemented (i2d::ICalibrationProvider)

const i2d::ICalibration2d* CCharucoPerspectiveCalibrationSupplierComp::GetCalibration() const
{
	return GetWorkProduct();
}


//protected methods

bool CCharucoPerspectiveCalibrationSupplierComp::CalculateCalibration(const iimg::IBitmap& image, icalib::CPerspectiveCalibration2d& result) const
{
	result.Reset();

	const iprm::IParamsSet* paramsPtr = GetModelParametersSet();

	if (!m_pointGridExtractorCompPtr.IsValid()) {
		SendErrorMessage(0, "Points grid extractor is undefined");
		return false;
	}

	PointGridConsumer imagePoints;
	if (m_pointGridExtractorCompPtr->DoExtractFeatures(paramsPtr, image, imagePoints) != iproc::IProcessor::TS_OK) {
		SendErrorMessage(0, "Point grid cannot be extracted");
		return false;
	}

	double cellSize = *m_defaultCellSizeAttrPtr;
	if (m_cellSizeParamId.IsValid()) {
		iprm::TParamsPtr<imeas::INumericValue> checkboardParamsPtr(paramsPtr, *m_cellSizeParamId);
		if (checkboardParamsPtr.IsValid()) {
			imath::CVarVector params = checkboardParamsPtr->GetValues();
			if (params.GetElementsCount() > 0) {
				cellSize = params.GetElement(0);
			}
		}
	}

	//selected pattern
	iocv::COcvPointGridExtractorComp::Pattern patternType = iocv::COcvPointGridExtractorComp::PT_CHESSBOARD;
	if (m_patternTypeAttrPtr.IsValid()){
		iprm::TParamsPtr<iprm::ISelectionParam> patternTypeSelectionPtr(paramsPtr, *m_patternTypeAttrPtr);
		if (patternTypeSelectionPtr != nullptr){
			patternType = (iocv::COcvPointGridExtractorComp::Pattern)(patternTypeSelectionPtr->GetSelectedOptionIndex());
		}
	}
	//ChArUco
	if (patternType == iocv::COcvPointGridExtractorComp::PT_CHARUCOBOARD){
		std::shared_ptr<iocv::CCharucoBoard> quissBoardPtr = iocv::CCharucoBoard::quiss_template(10.5f);

		std::vector<cv::Point2f> objectPoints = quissBoardPtr->border_corners(imagePoints.m_ids);
		icalib::CPointGrid nominalPositions;
		nominalPositions.SetSizes(imagePoints.m_points.GetSizes());
		int k = 0;
		const int sizeX = nominalPositions.GetSize(0);
		const int sizeY = nominalPositions.GetSize(1);
		for (int y = 0; y < sizeY; ++y){
			for (int x = 0; x < sizeX; ++x){
				const cv::Point2f& p = objectPoints[k++];
				istd::TIndex<2> ind;
				ind.SetAt(0, x);
				ind.SetAt(1, y);
				i2d::CVector2d position(p.x,p.y);
				nominalPositions.SetAt(ind, position);
			}
		}

		iipr::CPerspCalibFinder calibFinder;
		return (calibFinder.FindPerspCalib(
			&nominalPositions.GetElements()[0],
			&imagePoints.m_points.GetElements()[0],
			int(imagePoints.m_points.GetElements().size()),
			result));

	}

	const i2d::ICalibration2d* gridTransformPtr = m_pointGridTransformation.IsValid() ? m_pointGridTransformation->GetCalibration() : NULL;

	icalib::CPointGrid nominalPositions;
	nominalPositions.SetSizes(imagePoints.m_points.GetSizes());

	const int sizeX = nominalPositions.GetSize(0);
	const int sizeY = nominalPositions.GetSize(1);
	const double stepX = m_invertXAttrPtr.IsValid() && *m_invertXAttrPtr ? -cellSize : cellSize;
	const double stepY = m_invertYAttrPtr.IsValid() && *m_invertYAttrPtr ? -cellSize : cellSize;
	const double gridTop = -(sizeY - 1) * 0.5 * stepY;
	const double gridLeft = -(sizeX - 1) * 0.5 * stepX;

	double nomY = gridTop;
	for (int y = 0; y < sizeY; ++y){
		double nomX = gridLeft;
		for (int x = 0; x < sizeX; ++x){
			i2d::CVector2d normalPos(nomX, nomY);
			istd::TIndex<2> ind;
			ind.SetAt(0, x);
			ind.SetAt(1, y);
			
			if (gridTransformPtr != NULL){
				i2d::CVector2d transform;
				if (gridTransformPtr->GetPositionAt(normalPos, transform)){
					nominalPositions.SetAt(ind, transform);
				}
				else{
					nominalPositions.SetAt(ind, normalPos);
				}
			}
			else{
				nominalPositions.SetAt(ind, normalPos);
			}

			nomX += stepX;
		}
		nomY += stepY;
	}

	iipr::CPerspCalibFinder calibFinder;
	return (calibFinder.FindPerspCalib(
		&nominalPositions.GetElements()[0],
		&imagePoints.m_points.GetElements()[0],
		int(imagePoints.m_points.GetElements().size()),
		result));

	//	//result.SetAffinePart(*gridTransformPtr->CreateCombinedCalibration(result));
	//	return true;
	//}
}


// reimplemented (iinsp::TSupplierCompWrap)

iinsp::ISupplier::WorkStatus CCharucoPerspectiveCalibrationSupplierComp::ProduceObject(ProductType& result) const
{
	if (!m_bitmapProviderCompPtr.IsValid()){
		return WS_FAILED;
	}

	const iimg::IBitmap* bitmapPtr = m_bitmapProviderCompPtr->GetBitmap();
	if (bitmapPtr == NULL){
		AddMessage(new ilog::CMessage(ilog::CMessage::IC_ERROR, 0, QT_TR_NOOP("Empty input image"), "PerspectiveCalibrationSupplier", "iocv::CCharucoPerspectiveCalibrationSupplierComp"));

		return WS_FAILED;
	}

	Timer performanceTimer(this, "Perspective calibration");

	if (!CalculateCalibration(*bitmapPtr, result)) {
		return WS_FAILED;
	}

	return WS_OK;
}


} // namespace iocv


